## Harjoitustyöraportti

Palauttajat (max 3): Toni Moilanen
Pisteitä yhteensä: 0

## Ongelma 1
Tyyppi: Autentikointi
Sijainti: Koko sovellus
Kuvaus:

Sovellus käyttää keksejä käyttäjän tunnistamiseen ja seuraamiseen sivulta toiselle.
Keksejä voidaan kuitenkin manipuloida, minkä seurauksena esimerkiksi käyttäjää 
voidaan vaihtaa ilman autentikointia. Tämän lisäksi joillekin sivuille pääsee ilman
kirjautumista. 

### Esimerkkihyökkäys:
1) Kirjaudu käyttäjällä sue
2) Vaihda kirjautumisen jälkeen keksin username arvo lion
3) Tulos: Päästään käyttäjän lion tunnukselle

### Korjaus:
Tehdään järjestelmään autentikointi.

Commit: 0536511

Korjasin tämän käyttämällä Flaskin Flask-Login moduulia. Moduulissa on session
seurantaan toiminnot, jolloin sisään kirjautumista voidaan seurata luotettavasti.

Uskon korjauksen toimivan, sillä Flask-Login on Flaskin suositeltu moduuli sessioiden
seuraamiseen.

Korjaus rajoittaa keksien avulla käyttäjien manipuloinnin sekä auttaa seuraamaan, että
kuka sivustolla on kirjautuneena.

### Pisteet(3pt)

1pt vian löytämisestä
1pt vian korjaamisesta
1pt vikatyypin eliminoimisesta





## Ongelma 2
Tyyppi: Ajastushyökkäys
Sijainti: login()
Kuvaus:
Kirjautuessa salasanan vertailuun käytetään "==". Tämä mahdollistaa ajastushyökkäyksen.

Tämä ongelma täytyi korjata autentikointia korjattaessa, koska en osannut tehdä autentikointia
ilman tämän heikkouden korjaamista. Tästä syystä tämä korjaus näkyy samassa commitissa autenti-
koinnin korjaamisen kanssa.

### Esimerkkihyökkäys:
1) Kokeile kirjautua käyttäjälle sue
2) Syötä salasana ja kellota
3) Tulos: Salasana voidaan murtaa kellotuksen perusteella 

### Korjaus:
Käytetään salasanan tarkistamiseen kirjastoa.

Commit: 0536511

Korjasin tämän heikkouden käyttämällä werkzeug.security kirjastoa. Hashasin salasanat ja lisäsin
niihin salaisen merkkijonon. Tämän seurauksena ajastamisen pitäisi olla huomattavasti haastavampaa,
kuin "=="-vertailulla. En saanut mistään selville, että onko check_password_hash sellainen funktio, 
joka tekee ajastuksen täysin mahdottomaksi.

### Pisteet(3pt)

1pt vian löytämisestä
1pt vian korjaamisesta
1pt vikatyypin eliminoimisesta




## Ongelma 3
Tyyppi: XSS-Hyökkäys
Sijainti: Ympäri ohjelmaa
Kuvaus:
Käyttäjällä on erinäisissä kohdissa ohjelmaa mahdollisuus sijoittaa HTML:n sekaan omaa
HTML:ää.


### Esimerkkihyökkäys:
1) Nimeä tiedosto esim. --><!-- ---> <img src=xxx:x onerror=javascript:alert('xss')> -->
2) Lataa palvelimelle
3) Tulos: Ohjelma suorittaa nimeen syötetyn koodin.

### Korjaus:
Commit: 1441887

Syötetään HTML:n sekaan käyttäjän syötteet turvallisesti, eli korvataan:

'''<h1>File shared: %s</h1>''' % user_input ---> render_template_string('''{{user_input}} ''',
user_input = user_input).

Tällöin Flaskin autoescape estää koodin ajamisen. Tämä ei kuitenkaan toimi <a href=user_input>
tilanteissa, minkä vuoksi user_content() funktiossa täytyy tehdä muita muutoksia.

Lähestymistapani on tiedostojen nimien muuttaminen palvelimella siten, että niillä on käytännössä
uniikki nimi.

Tein seuraavan asian: luetaan tiedoston nimi ja asetetaan se <a href=user_input> hashattuna.
Tämän seurauksena linkkeihin ei voi sijoittaa mitään haitallista. Ohjelmaa täytyi muokata siten,
että käyttäjän syötteet mukautettiin myös hashiksi ja vertailu toteutetaan tätä kautta. Pyrin siihen,
että jokaisessa paikassa kuitenkin näkyy alkuperäinen tiedostonimi ja järjestelmässä voi usealla
eri käyttäjällä olla saman nimisiä tiedostoja, mutta niiden avulla ei voida poistaa toisen käyttäjän
jakamia tiedostoja.

Korjaukseni jälkeen en keksi tapoja toteuttaa nykyiseen järjestelmään XSS-hyökkäystä.

### Pisteet(3pt)

1pt vian löytämisestä
1pt vian korjaamisesta
1pt vikatyypin eliminoimisesta





## Ongelma 4
Tyyppi: Shell-injektio
Sijainti: checkerLoop()
Kuvaus:
filename = queue.get(). Käyttäjä voi antaa filenameksi mitä vain, jolloin syntyy injektiolle mahdollisuus,
sillä filename syötetään suoraan shelli käskyyn. Tämä tapahtuu kohdassa:

res = subprocess.run(
            "file %s" % filename,
            shell=True,
            timeout=15,
            stdout=subprocess.PIPE)

### Esimerkkihyökkäys:
1) Käyttäjä syöttää palvelimelle tiedoston, jonka nimi on: nimi | ls
2) Tulos: Palvelin suorittaa |-merkin jälkeisen komennon

### Korjaus:
Commit: d55cdf7

Tarkistetaan tiedosto jollakin toisella menetelmällä. Käytin tiedoston tarkistukseen python-magic moduulia.

Python-magic moduuli tarkistaa tiedoston MIME-otsakkeiden avulla. Tarkistuksen pitäisi olla kohtalaisen varma,
mutta lukemani perusteella MIME:n voi "feikata", jonka seurauksena osaava hakkeri voi ladata palvelimelle
jotakin sellaista, mitä sinne ei pitäisi saada ladata.

Tämä ei ole kuitenkaan kurssin asiaa, ja Shell-injektio on tällä tavoin estetty.

### Pisteet(3pt)

1pt vian löytämisestä
1pt vian korjaamisesta
1pt vikatyypin eliminoimisesta





## Ongelma 5
Tyyppi: Polkuinjektio
Sijainti: Koko sovellus
Kuvaus:

Sovelluksessa on käytetty paljon polkujen rakentamiseen jonojen liimailua. Tämä aiheuttaa heikkouksia, joiden
seurauksena voidaan toteuttaa polkuinjektioita.

path = configuration['web_root'] + '/' + username + "/" + user_file

### Esimerkkihyökkäys:
1) Mikäli sivustoa laajennettaisiin ja käyttäjä voisi tehdä sinne tunnuksen, niin käyttäjänimellä ../lion
päästäisiin käyttäjän lion tiedostoihin käsiksi. (Injektiota on vaikea demonstroida tässä kohtaa ohjelman
parannusta, mutta injektioiden mahdollisuus on olemassa.)

### Korjaus:

Commit: <git hash>

Korjasin 

### Pisteet(3pt)

1pt vian löytämisestä
1pt vian korjaamisesta
1pt vikatyypin eliminoimisesta









