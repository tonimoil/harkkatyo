## Harjoitustyöraportti

Palauttajat (max 3): Toni Moilanen
Pisteitä yhteensä: 0

## Ongelma 1
Tyyppi: Autentikointi
Sijainti: Koko sovellus
Kuvaus:

Sovellus käyttää keksejä käyttäjän tunnistamiseen ja seuraamiseen sivulta toiselle.
Keksejä voidaan kuitenkin manipuloida, minkä seurauksena esimerkiksi käyttäjää 
voidaan vaihtaa ilman autentikointia. Tämän lisäksi joillekin sivuille pääsee ilman
kirjautumista. 

### Esimerkkihyökkäys:
1) Kirjaudu käyttäjällä sue
2) Vaihda kirjautumisen jälkeen keksin username arvo lion
3) Tulos: Päästään käyttäjän lion tunnukselle

### Korjaus:
Tehdään järjestelmään autentikointi.

Commit: <git hash>

Korjasin tämän käyttämällä Flaskin Flask-Login moduulia. Moduulissa on session
seurantaan toiminnot, jolloin sisään kirjautumista voidaan seurata luotettavasti.

Uskon korjauksen toimivan, sillä Flask-Login on Flaskin suositeltu moduuli sessioiden
seuraamiseen.

Korjaus rajoittaa keksien avulla käyttäjien manipuloinnin sekä auttaa seuraamaan, että
kuka sivustolla on kirjautuneena.

### Pisteet(3pt)

1pt vian löytämisestä
1pt vian korjaamisesta
1pt vikatyypin eliminoimisesta





## Ongelma 2
Tyyppi: Ajastushyökkäys
Sijainti: login()
Kuvaus:

Kirjautuessa salasanan vertailuun käytetään "==". Tämä mahdollistaa ajastushyökkäyksen.

Tämä ongelma täytyi korjata autentikointia korjattaessa, koska en osannut tehdä autentikointia
ilman tämän heikkouden korjaamista. Tästä syystä tämä korjaus näkyy samassa commitissa autenti-
koinnin korjaamisen kanssa.

### Esimerkkihyökkäys:
1) Kokeile kirjautua käyttäjälle sue
2) Syötä salasana ja kellota
3) Tulos: Salasana voidaan murtaa kellotuksen perusteella 

### Korjaus:
Käytetään salasanan tarkistamiseen kirjastoa.

Commit: <git hash>

Korjasin tämän heikkouden käyttämällä werkzeug.security kirjastoa. Hashasin salasanat ja lisäsin
niihin salaisen merkkijonon. Tämän seurauksena ajastamisen pitäisi olla huomattavasti haastavampaa,
kuin "=="-vertailulla. En saanut mistään selville, että onko check_password_hash sellainen funktio, 
joka tekee ajastuksen täysin mahdottomaksi.

### Pisteet(2pt)

1pt vian löytämisestä
1pt vian korjaamisesta




## Ongelma 1
Tyyppi:   Polkuinjektio
Sijainti: delete_file()
Kuvaus:

Aliohjelmassa delete_file ei tarkasteta käyttäjän syöttämää polkua
millään tavalla. Tämä mahdollistaa sen, että käyttäjä tuhoaa minkä
tahansa tiedoston, esimerkiksi toisen käyttäjän tiedoston tai vaikkapa
jonkin järjestelmätiedoston.

### Esimerkkihyökkäys: 

1) Kirjaudu sisään käyttäjänä "sam".
2) Tee pyyntö /delete_file?file=../sue/tiedosto.txt
3) Tulos: Suen tiedosto tuhotaan

### Korjaus:

Commit: <git hash>

Korjasin tämän näin... 

Korjaus toimii koska... 

Korjaus estää uuden polkuinjektion syntymisen, sillä uutta reittiä luotaessa...

### Pisteet(3pt)

1pt vian löytämisestä
1pt vian korjaamisesta
1pt vikatyypin eliminoimisesta



## Ongelma 2
Tyyppi: Shell-injektio
Sijainti: checkerLoop()
Kuvaus:

filename = queue.get(). Käyttäjä voi antaa filenameksi mitä vain, jolloin syntyy injektiolle mahdollisuus,
sillä filename syötetään suoraan shelli käskyyn. Tämä tapahtuu kohdassa:

res = subprocess.run(
            "file %s" % filename,
            shell=True,
            timeout=15,
            stdout=subprocess.PIPE)

### Esimerkkihyökkäys:
1) Käyttäjä syöttää palvelimelle tiedoston, jonka nimi on: nimi | ls
2) Tulos: Palvelin suorittaa |-merkin komennon

### Korjaus:

Commit: <git hash>



## Ongelma 3
Tyyppi: Polkuinjektio
Sijainti: login()
Kuvaus:

login-funktion autentikointi mahdollistaa kirjautumisen palvelimelle ilman perustettua tunnusta.
Tämän lisäksi funkiosta löytyvä käyttäjän kansion polku mahdollistaa tämän seurauksena polkuinjektion.
Molemmat seikat ovat epätoivottua toiminnallisuutta, joten login funktio tulee tehdä uudelleen.

Hyökkäys toimii siitä syystä, että autentikointi on toteutettu todella huonosti. "if username" tarkistaa
ensin, että onko käyttäjänimi syötetty. Tämän jälkeen tarkistetaan "if users.get(username) == password".
Jos käyttäjänimeä ei ole perustettu, niin tämä ehtolause toteutuu.

Tässä on lisäksi huomioitava se, että mikäli palvelimelle olisi mahdollista luoda käyttäjätunnuksia, niin
hyökkääjä voisi tehdä uusia tunnuksia ja niiden kautta toteuttaa saman polkuinjektion. Tästä syystä myöskin
käyttäjänimien merkkejä olisi hyvä rajoittaa.

### Esimerkkihyökkäys:

1) Syötetään osoite localhost:5000/login?user=../WebData/sue
2) Tulos: Päästään palvelimelle ja käsiksi käyttäjän sue tiedostoihin

### Korjaus:

Commit: <git hash>