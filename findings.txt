## Harjoitustyöraportti

Palauttajat (max 3): Toni Moilanen
Pisteitä yhteensä: 0

## Ongelma 1
Tyyppi: Autentikointi
Sijainti: Koko sovellus
Kuvaus:

Sovellus käyttää keksejä käyttäjän tunnistamiseen ja seuraamiseen sivulta toiselle.
Keksejä voidaan kuitenkin manipuloida, minkä seurauksena esimerkiksi käyttäjää 
voidaan vaihtaa ilman autentikointia. Tämän lisäksi joillekin sivuille pääsee ilman
kirjautumista. 

### Esimerkkihyökkäys:
1) Kirjaudu käyttäjällä sue
2) Vaihda kirjautumisen jälkeen keksin username arvo lion
3) Tulos: Päästään käyttäjän lion tunnukselle

### Korjaus:
Tehdään järjestelmään autentikointi.

Commit: 0536511

Korjasin tämän käyttämällä Flaskin Flask-Login moduulia. Moduulissa on session
seurantaan toiminnot, jolloin sisään kirjautumista voidaan seurata luotettavasti.

Uskon korjauksen toimivan, sillä Flask-Login on Flaskin suositeltu moduuli sessioiden
seuraamiseen.

Korjaus rajoittaa keksien avulla käyttäjien manipuloinnin sekä auttaa seuraamaan, että
kuka sivustolla on kirjautuneena.

### Pisteet(3pt)

1pt vian löytämisestä
1pt vian korjaamisesta
1pt vikatyypin eliminoimisesta





## Ongelma 2
Tyyppi: Ajastushyökkäys
Sijainti: login()
Kuvaus:
Kirjautuessa salasanan vertailuun käytetään "==". Tämä mahdollistaa ajastushyökkäyksen.

Tämä ongelma täytyi korjata autentikointia korjattaessa, koska en osannut tehdä autentikointia
ilman tämän heikkouden korjaamista. Tästä syystä tämä korjaus näkyy samassa commitissa autenti-
koinnin korjaamisen kanssa.

### Esimerkkihyökkäys:
1) Kokeile kirjautua käyttäjälle sue
2) Syötä salasana ja kellota
3) Tulos: Salasana voidaan murtaa kellotuksen perusteella 

### Korjaus:
Käytetään salasanan tarkistamiseen kirjastoa.

Commit: 0536511

Korjasin tämän heikkouden käyttämällä werkzeug.security kirjastoa. Hashasin salasanat ja lisäsin
niihin salaisen merkkijonon. Tämän seurauksena ajastamisen pitäisi olla huomattavasti haastavampaa,
kuin "=="-vertailulla. En saanut mistään selville, että onko check_password_hash sellainen funktio, 
joka tekee ajastuksen täysin mahdottomaksi.

### Pisteet(2pt)

1pt vian löytämisestä
1pt vian korjaamisesta





## Ongelma 3
Tyyppi: XSS-Hyökkäys
Sijainti: Ympäri ohjelmaa
Kuvaus:
Käyttäjällä on erinäisissä kohdissa ohjelmaa mahdollisuus sijoittaa HTML:n sekaan omaa
HTML:ää.


### Esimerkkihyökkäys:
1) Nimeä tiedosto esim. --><!-- ---> <img src=xxx:x onerror=javascript:alert('xss')> -->
2) Lataa palvelimelle
3) Tulos: Ohjelma suorittaa nimeen syötetyn koodin.

### Korjaus:
Commit: 9ad61c7

Syötetään HTML:n sekaan käyttäjän syötteet turvallisesti, eli korvataan:

'''<h1>File shared: %s</h1>''' % user_input ---> render_template_string('''{{user_input}} ''',
user_input = user_input).

Tällöin Flaskin autoescape estää koodin ajamisen. Tämä ei kuitenkaan toimi <a href=user_input>
tilanteissa, minkä vuoksi user_content() funktiossa täytyy tehdä muita muutoksia.

Lähestymistapani on tiedostojen nimien muuttaminen palvelimella siten, että niillä on käytännössä
uniikki nimi.

Tein seuraavan asian: luetaan tiedoston nimi ja asetetaan se <a href=user_input> hashattuna.
Tämän seurauksena linkkeihin ei voi sijoittaa mitään haitallista. Ohjelmaa täytyi muokata siten,
että käyttäjän syötteet mukautettiin myös hashiksi ja vertailu toteutetaan tätä kautta. Pyrin siihen,
että jokaisessa paikassa kuitenkin näkyy alkuperäinen tiedostonimi ja järjestelmässä voi usealla
eri käyttäjällä olla saman nimisiä tiedostoja, mutta niiden avulla ei voida poistaa toisen käyttäjän
jakamia tiedostoja.

Korjaukseni jälkeen en keksi tapoja toteuttaa nykyiseen järjestelmään XSS-hyökkäystä. Korjaus on
kuitenkin suhteellisen sekainen ja vaikeasti laajennettavissa.

### Pisteet(2pt)

1pt vian löytämisestä
1pt vian korjaamisesta






## Ongelma 4
Tyyppi: Shell-injektio
Sijainti: checkerLoop()
Kuvaus:
filename = queue.get(). Käyttäjä voi antaa filenameksi mitä vain, jolloin syntyy injektiolle mahdollisuus,
sillä filename syötetään suoraan shelli käskyyn. Tämä tapahtuu kohdassa:

res = subprocess.run(
            "file %s" % filename,
            shell=True,
            timeout=15,
            stdout=subprocess.PIPE)

### Esimerkkihyökkäys:
1) Käyttäjä syöttää palvelimelle tiedoston, jonka nimi on: nimi | ls
2) Tulos: Palvelin suorittaa |-merkin jälkeisen komennon

### Korjaus:

Commit: <git hash>

### Pisteet(3pt)

1pt vian löytämisestä
1pt vian korjaamisesta
1pt vikatyypin eliminoimisesta





## Ongelma x
Tyyppi: 
Sijainti: 
Kuvaus:


### Esimerkkihyökkäys:
1) 

### Korjaus:

Commit: <git hash>

### Pisteet(3pt)

1pt vian löytämisestä
1pt vian korjaamisesta
1pt vikatyypin eliminoimisesta









